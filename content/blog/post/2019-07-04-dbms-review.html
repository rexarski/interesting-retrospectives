---
title: DBMS Review
author: Qiu Rui
date: '2019-07-04'
slug: dbms-review
categories: []
tags:
  - SQL
---



<ul>
<li>3-level ANSI/SPARC architecture
<ul>
<li>external level (views) -&gt;</li>
<li>conceptual/logical level (entities, relationships, constraints)</li>
<li>internal level (physical files, blocks, pointers)</li>
</ul></li>
<li>A <strong>relation</strong> is a subset of a Cartesian product of sets.</li>
</ul>
<div id="relational-data-model" class="section level2">
<h2>Relational Data Model</h2>
<ul>
<li>Schema and State
<ul>
<li>correspondence of terms
<ul>
<li>table &lt;=&gt; relation</li>
<li>column &lt;=&gt; attribute</li>
<li>data type &lt;=&gt; domain</li>
<li>row &lt;=&gt; tuple</li>
<li>table definition &lt;=&gt; relation schema</li>
</ul></li>
</ul></li>
<li>A <strong>relation schema</strong> has a <strong>relation name</strong> and a list of <strong>attributes</strong>.</li>
<li>Each attribute is associated with a <strong>domain</strong></li>
<li>A <strong>tuple</strong> in relation <span class="math inline">\(R\)</span> is a list <span class="math inline">\(t\)</span> of values.</li>
<li>A <strong>relation</strong> <span class="math inline">\(r(R)\)</span> is a set of tuples.</li>
<li>A <strong>relational database schema</strong> <span class="math inline">\(S\)</span> is
<ul>
<li>a set of relation schemas <span class="math inline">\(S=\{R_1,\dots,R_m\}\)</span> and</li>
<li>a set of integrity constraints <span class="math inline">\(IC\)</span></li>
</ul></li>
<li>A <strong>relational database state</strong> of <span class="math inline">\(S\)</span> is a set of relations such that
<ul>
<li>there is just one relation for each relation schema in <span class="math inline">\(S\)</span> and</li>
<li>all the relations satisfy the integrity constraints <span class="math inline">\(IC\)</span></li>
</ul></li>
<li>Integrity Constraints
<ul>
<li>main types of constraints
<ul>
<li>domain constraints
<ul>
<li>every value in a tuple must be from the <strong>domain of its attribute</strong></li>
<li>possible domains:
<ul>
<li><code>INT</code></li>
<li><code>VARCHAR</code></li>
<li><code>DATE</code></li>
<li><code>SMALLINT</code></li>
<li><code>NOT NULL</code></li>
</ul></li>
</ul></li>
<li>key constraints
<ul>
<li>A <strong>superkey</strong> <span class="math inline">\(SK\)</span> of <span class="math inline">\(R\)</span> is a subset of attributes of <span class="math inline">\(R\)</span> such that <em>no two distinct tuples in <span class="math inline">\(r(R)\)</span> can have the same value for <span class="math inline">\(SK\)</span></em>.</li>
<li>A superkey <span class="math inline">\(SK\)</span> is <strong>minimal</strong> if there is no other superkey <span class="math inline">\(SK&#39;\subset SK\)</span> held on <span class="math inline">\(R\)</span>, it is also known as a <strong>candidate key</strong>.</li>
<li>A <strong>primary key</strong> <span class="math inline">\(PK\)</span> of <span class="math inline">\(R\)</span> is a minimal superkey of <span class="math inline">\(R\)</span>.</li>
</ul></li>
<li>entity integrity constraints
<ul>
<li><strong>no primary key value can be <code>NULL</code></strong></li>
</ul></li>
<li>referential integrity constraints
<ul>
<li>A <strong>referential integrity constraint</strong> specifies a reference between two relations, while the previous constraints involve only one relation.</li>
<li>A <strong>foreign key</strong> on <span class="math inline">\(R_1\)</span> is a statement <span class="math inline">\([A_1,\dots, A_n]\subseteq R_2[B_1,\dots, B_n]\)</span> restricting states of <span class="math inline">\(S\)</span> to satisfy the following property:
<ul>
<li>for each tuple <span class="math inline">\(t\in r(R_1)\)</span> there exists a tuple <span class="math inline">\(t&#39;\in r(R_2)\)</span> with <span class="math inline">\(t[A_i]=t&#39;[B_i]\)</span> for <span class="math inline">\(i=1,\dots, n\)</span>.</li>
<li><span class="math inline">\(R_1\)</span> is called the <strong>referencing relation</strong> and <span class="math inline">\(R_2\)</span> is called the <strong>referenced relation</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="sql" class="section level2">
<h2>SQL</h2>
<ul>
<li>SQL = <strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage</li>
<li>SQL provides an interface to relational database systems including:
<ul>
<li>Data Definition Language (DDL)</li>
<li>Data Manipulation Language (DML)</li>
<li>Data Control Language (DCL)</li>
<li>Transaction Control Language (TCL)</li>
</ul></li>
</ul>
<div id="ddl" class="section level3">
<h3>DDL</h3>
<div id="create-table" class="section level4">
<h4><code>CREATE TABLE</code></h4>
<pre class="sql"><code>CREATE TABLE table_name
    (attribute_name data_type) [attribute constraints],
     ...,
     attribute_name data_type) [attribute constraints],
    [table constraints]);</code></pre>
<ul>
<li><strong>Attribute Data Type</strong>
<ul>
<li>numeric types
<ul>
<li><code>INT</code> and <code>SMALLINT</code> -&gt; integers of various sizes</li>
<li><code>FLOAT</code> or <code>REAL</code>, and <code>DOUBLE PRECISION</code> -&gt; floating point numbers of various precision</li>
<li><code>NUMERIC(i,j)</code> or <code>DECIMAL(i,j)</code> -&gt; fixed point numbers with <em>precision <span class="math inline">\(i\)</span></em> and <em>scale <span class="math inline">\(j\)</span></em>, where:
<ul>
<li><strong>precision</strong> = total number of digits;</li>
<li><strong>scale</strong> = the number of digits following the decimal point</li>
</ul></li>
</ul></li>
<li>string types
<ul>
<li><code>CHAR(n)</code> -&gt; character strings of fixed length <span class="math inline">\(n\)</span></li>
<li><code>VARCHAR(n)</code> -&gt; character strings of varying length no longer than <span class="math inline">\(n\)</span></li>
<li><code>BIT(n)</code> -&gt; bit strings of fixed length <span class="math inline">\(n\)</span></li>
<li><code>BIT VARYING(n)</code> -&gt; …</li>
</ul></li>
<li>data and time types
<ul>
<li><code>DATE</code> -&gt; date values</li>
<li><code>TIME</code> -&gt; time values</li>
<li><code>TIMESTAMP</code> -&gt; <code>DATE</code> and <code>TIME</code> fields, plus a minimum of six positions for seconds and an optional <code>WITH TIME ZONE</code> quanlifier</li>
<li><code>INTERVAL</code> -&gt; …</li>
</ul></li>
<li>booleantype: <code>TRUE</code> or <code>FALSE</code></li>
</ul></li>
</ul>
<pre class="sql"><code>CREATE DOMAIN domain_name AS data_type
    [default expression] [constraint, ..., constraint];</code></pre>
<ul>
<li><p><code>CREATE DOMAIN</code> statement is used to create a domain that is essentially a specific data type.</p></li>
<li><p><strong>Attribute Constraints</strong></p>
<ul>
<li><code>NOT NULL</code></li>
<li><code>DEFAULT</code></li>
<li><code>CHECK (...)</code></li>
<li><code>UNIQUE</code> -&gt; automatically imply <code>NOT NULL</code></li>
<li><code>PRIMARY KEY</code> -&gt; automatically imply <code>NOT NULL</code></li>
<li><code>FOREIGN KEY (...) REFERENCES ... (...)</code></li>
<li><code>INDEX</code>: fast retrieval based on columns other than the primary key</li>
</ul></li>
</ul>
<pre class="sql"><code>CREATE INDEX index1 ON CUSTOMER (Name, DOB);
CREATE UNIQUE INDEX index2 ON CUSTOMER (Phone);</code></pre>
</div>
<div id="alter-table" class="section level4">
<h4><code>ALTER TABLE</code></h4>
<ul>
<li>modify an existing relation schema
<ul>
<li>changing the name of a table</li>
<li>adding or dropping an attribute</li>
<li>changing the definition of an attribute</li>
<li>adding or dropping table constraints</li>
</ul></li>
<li>Add a <code>NOT NULL</code> constraint
<ul>
<li><code>ALTER TABLE CUSTOMER ALTER COLUMN Address SET NOT NULL;</code></li>
</ul></li>
<li>Add a <code>UNIQUE</code> constraint
<ul>
<li><code>ALTER TABLE CUSTOMER ADD UNIQUE(Phone);</code></li>
</ul></li>
<li>Add a <code>CHECK()</code> constraint
<ul>
<li><code>ALTER TABLE CUSTOMER ADD CONSTRAINT positive_id CHECK (CustomerID &gt; 0);</code></li>
</ul></li>
<li>Add a Foreign Key constraint
<ul>
<li><code>ALTER TABLE ENROL ADD FOREIGN KEY(StudentID) REFERENCES Student(StudentID);</code></li>
</ul></li>
<li>Add an attribute <code>Email</code> into the table <code>CUSTOMER</code>
<ul>
<li><code>ALTER TABLE CUSTOMER ADD Email VARCHAR(100);</code></li>
</ul></li>
<li>Drop the attribute
<ul>
<li><code>ALTER TABLE CUSTOMER DROP COLUMN Email;</code></li>
</ul></li>
</ul>
</div>
<div id="drop-table" class="section level4">
<h4><code>DROP TABLE</code></h4>
<ul>
<li><p>remove an existing relation schema from a database schema</p></li>
<li><p>Drop the table</p>
<ul>
<li><code>DROP TABLE ENROL;</code></li>
</ul></li>
<li><p>Drop the table (if exists)</p>
<ul>
<li><code>DROP TABLE IF EXISTS CUSTOMER;</code></li>
</ul></li>
</ul>
<p>2018-10-04</p>
</div>
</div>
<div id="dml" class="section level3">
<h3>DML</h3>
<div id="insert" class="section level4">
<h4><code>INSERT</code></h4>
<ul>
<li>used to add tuples into a relation</li>
</ul>
<pre class="sql"><code>INSERT INTO table_name
        [(attributee_name,...,attribute_name)]
    VALUES (value,...,value),...,(value,...,value);</code></pre>
<ul>
<li><strong>Primary key violation:</strong> DBMS will not allow two tuples with the same primary key value in a relation.</li>
<li><strong>Foreign key violation:</strong></li>
</ul>
</div>
<div id="update" class="section level4">
<h4><code>UPDATE</code></h4>
<ul>
<li>used to modify attribute values of one or more selected tuples</li>
</ul>
<pre class="sql"><code>UPDATE table_name
    SET attribute_name = value,...,attribute_name = value
[WHERE selection_condition];</code></pre>
</div>
<div id="delete" class="section level4">
<h4><code>DELETE</code></h4>
<ul>
<li>used to remove tuples from a relation</li>
</ul>
<pre class="sql"><code>DELETE FROM table_name
    [WHERE selection_condition];</code></pre>
<ul>
<li><code>DELETE FROM STUDENT;</code> vs <code>DROP Table STUDENT;</code>
<ul>
<li>the (empty) table exists after the first statement</li>
</ul></li>
</ul>
</div>
<div id="update-and-deletee---referential-actions" class="section level4">
<h4>Update and Deletee - Referential Actions</h4>
<ul>
<li>in case of deleting or updating referenced tuples (via foreign key constraints)
<ul>
<li><code>NO ACTION</code> (default) -&gt; will throw an error if one tries to delete a row (or update the primary key value) referenced</li>
<li><code>CASCADE</code> -&gt; force the referencing tuples to be deleted (or updated with new primary key value)</li>
<li><code>SET NULL</code> -&gt; force the corresponding values in the referencing tuples to be set to a null value</li>
<li><code>SET DEFAULT</code> -&gt; … specified default value</li>
</ul></li>
</ul>
<pre class="sql"><code>CREATE TABLE ENROL
    (StudentID INT,
     CourseNo VARCHAR(20),
     Semester VARCHAR(50),
     Status VARCHAR(50),
     FOREIGN KEY(StudentID) REFERENCES STUDENT(StudentID)
      ON DELETE NO ACTION,
     FOREIGN KEY(CourseNo) REFERENCES COURSE(No));</code></pre>
</div>
<div id="simple-sql-queries" class="section level4">
<h4>Simple SQL Queries</h4>
<ul>
<li>The <code>SELECT</code> statement has the following basic form:</li>
</ul>
<pre class="sql"><code>SELECT attribute_list
FROM table_list
[WHERE condition]
[GROUP BY attribute_list [HAVING group_condition]]
[ORDER BY attribute_list];</code></pre>
<ul>
<li><p>only <code>SELECT</code> and <code>FROM</code> are mandatory</p></li>
<li><p><code>*</code> means all the attributes</p></li>
<li><p>attribute names may be qualified with the table name</p></li>
<li><p>attribute and table names can be given an alias</p></li>
<li><p><code>DISTINCT</code> is used for removing duplicate tuples in the query result</p></li>
<li><p>unspecified <code>WHERE</code>-clause means no condition</p></li>
<li><p><code>BETWEEN ... AND ...;</code></p></li>
<li><p><code>is NOT NULL;</code></p></li>
<li><p><code>like '%@gmail.com';</code></p></li>
<li><p><code>GROUP BY attribute_list</code> groups tuples for each value combination in the attribute_list</p>
<ul>
<li>aggregate functions can be applied
<ul>
<li><code>COUNT</code></li>
<li><code>AVG</code></li>
<li><code>MIN</code></li>
<li><code>MAX</code></li>
<li><code>SUM</code></li>
</ul></li>
<li>can use <code>HAVING</code> <em>condition</em> to add the condition on the groups</li>
</ul></li>
</ul>
<p>e.g.</p>
<pre class="sql"><code>SELECT COUNT(*), SUM(unit), MIN(unit)
FROM COURSE;

SELECT e.CourseNo, COUNT(*) AS NumberOfStudents
FROM ENROL e
WHERE e.Semester = &#39;2016 S2&#39;
GROUP BY e.CourseNo
HAVING COUNT(*) &gt;= 120;
ORDER BY NumberOfStudents DESC;</code></pre>
<ul>
<li>the <code>ORDER BY</code> clause allows us to sort the tuples in a query result
<ul>
<li><code>ASC</code> asecending order (default)</li>
<li><code>DESC</code> descending order</li>
</ul></li>
</ul>
</div>
<div id="advanced-sql-queries" class="section level4">
<h4>Advanced SQL Queries</h4>
<ul>
<li><p>set operations</p>
<ul>
<li><code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code></li>
<li>set operations result in return of a relation of tuples (<strong>no duplicates</strong>)</li>
<li>set operations apply to relations that <strong>have the same attribute types appearing in the same order</strong></li>
</ul></li>
<li><p><code>JOIN</code> operations</p></li>
<li><p><code>INNER JOIN</code>: tupples are inclueded in the result only if there is at least one matching in both relations.</p></li>
</ul>
<pre class="sql"><code>SELECT DISTINCT c.Cname
FROM COURSE c INNER JOIN ENROL e ON c.No=e.CourseNo;</code></pre>
<ul>
<li><code>OUTER JOIN</code>: <code>LEFT JOIN</code> and <code>RIGHT JOIN</code>
<ul>
<li>all tuples of the left/right table are included in the result, even if there are no matches in the relations</li>
</ul></li>
</ul>
<pre class="sql"><code>SELECT s.*, e.CourseNo, e.Semester
FROM STUDENT s LEFT JOIN ENROL1 e ON s.StudentID=e.StudentID;

SELECT s.*, e.CourseNo, e.Semester
FROM ENROL1 e RIGHT JOIN STUDENT s ON e.STudentID=s.StudentID;</code></pre>
<ul>
<li><strong>motivation:</strong> an inner join retains all the data of the two tables for, with duplication (in columns)</li>
<li><code>NATURAL JOIN</code>: a natural join retains <strong>all the data of the two tables for only the matched rows, without duplication</strong>
<ul>
<li>it is one kind of inner join, in which two relations are joined implicitly by <strong>comparing all attributes of the same names in both relations</strong></li>
</ul></li>
</ul>
<pre class="sql"><code>SELECT *
FROM STUDENT s NATURAL JOIN ENROL1 e;</code></pre>
<ul>
<li><strong>Subqueries</strong> are just queries that are used where a relation is required
<ul>
<li>within the <code>FROM</code>-clause to create <em>inline view</em> (exists only for the query)</li>
<li>within the <code>WHERE</code>-clause
<ul>
<li><code>IN</code> subquery tests if tuple occurs in the result of the subquery</li>
<li><code>EXISTS</code> subquery tests whether the subquery results in non-empty relation</li>
<li><code>ALL</code>, <code>SOME</code>, <code>ANY</code></li>
<li><code>NOT</code></li>
</ul></li>
</ul></li>
</ul>
<pre class="sql"><code>SELECT s.*, e1.CourseNo
FROM STUDENT s NATURAL JOIN ENROL e1
WHERE e1.CourseNo IN 
    (SELECT e2.CourseNo
     FROM ENROL e2
     GROUP BY e2.CourseNo
     HAVING COUNT(*)&lt;10);

SELECT s.*
FROM STUDENT s
WHERE EXISTS (SELECT *
              FROM ENROL e
              WHERE s.StudentID=e.StudentID);

SELECT s.*
FROM STUDENT s
WHERE NOT EXISTS (SELECT *
                  FROM ENROL e
                  WHERE s.StudentID=e.StudentID);</code></pre>
<ul>
<li>A <strong>view</strong> in SQL is a <strong>virtual table</strong> that is derived from other tables in the same database or previously defined views</li>
</ul>
<pre class="sql"><code>CREATE VIEW ENROL1
AS SELECT s.StudentID, s.Name, e.CourseNo, e.EnrolDate
FROM STUDENT s, ENROL e
WHERE s.StudentID=e.StudentID;</code></pre>
<hr />
</div>
</div>
</div>
<div id="entity-relationship-er-model" class="section level2">
<h2>Entity-Relationship (ER) Model</h2>
<ul>
<li><p>a data model normally has 3 key aspects:</p>
<ul>
<li><strong>data structure</strong>: data in the ER model is represented as <strong>entities</strong> and <strong>relationships</strong> with <strong>attributes</strong></li>
<li><strong>data integrity</strong>: <strong>keys</strong> are for entity/relationship types, and <strong>cardinality/participation constraints</strong> for relationship types</li>
<li><strong>data manipulation</strong>: <strong>no standard data manipulation operations</strong> are associated with the ER model</li>
</ul></li>
<li><p>ER diagrams:</p>
<ul>
<li>attributes -&gt; ovals</li>
<li>key attributes -&gt; underlined</li>
<li>entity types -&gt; rectangles</li>
<li>relationship types -&gt; diamonds</li>
</ul></li>
<li><p><strong>Entities</strong>: “things”</p></li>
<li><p><strong>Relationships</strong>: assocations between entities</p></li>
<li><p><strong>Attributes</strong>: properties that describe entities and relationships</p></li>
<li><p><strong>Domains of attributes</strong>: for each attribute, a domain is associated, i.e. a set of permitted values for an attribute.</p></li>
<li><p>An <strong>entity type</strong> defines a collection (or set) of entities that have the same attributes.</p>
<ul>
<li>described by its name and attributes</li>
</ul></li>
<li><p>An <strong>entity set</strong> is a collection of all entities of a particular entity type inthe db at any point in time.</p></li>
<li><p>A <strong>relationship type</strong> is an association between two or more entity types and can have attributes as well,</p>
<ul>
<li>Employee works-for Department</li>
<li>Employee registers a Customer at Branch office</li>
</ul></li>
<li><p><strong>Degree of relationship type</strong>: the number of participating entity types</p></li>
<li><p>A <strong>relationship set</strong> is the set of associations between entities of the entity types that participate in the relationship type</p></li>
<li><p>keys</p></li>
<li><p>constraints on relationships</p>
<ul>
<li><strong>cardinality ratios</strong>: specifies the maximum number of relationships that an entity can participate in
<ul>
<li>many-to-many</li>
<li>one-to-many</li>
<li>one-to-one</li>
</ul></li>
<li><strong>participation constraints</strong> (total, partial): specifies whether the existence of any entity depends on its being related to another entity via the relationship type.
<ul>
<li>total: e.g., each employee must work for a department and each department may or may not have employees.</li>
<li>partial (default): e.g. an employee may or may not work for a department and each department may or may not have employees.</li>
</ul></li>
<li><strong>cardinality limits</strong>: each entity type participating in a relationship type associates with a pair of integer numbers <code>(min, max)</code></li>
</ul></li>
<li><p><strong>recursive relationships</strong>: some entity type can participate more than once in a relationship type in different roles.</p>
<ul>
<li>a <strong>role name</strong> specifies the role that a participating entity plays in each relationship.</li>
</ul></li>
<li><p>A <strong>weak entity type</strong> is an entity that does not have sufficient attributes to form a primary key.</p>
<ul>
<li>identifying relationship</li>
</ul></li>
</ul>
</div>
<div id="enhanced-entity-relationship-eer-model" class="section level2">
<h2>Enhanced Entity-Relationship (EER) Model</h2>
<div id="subclasssuperclass" class="section level3">
<h3>Subclass/superclass</h3>
</div>
<div id="specializationgeneralization" class="section level3">
<h3>Specialization/generalization</h3>
</div>
<div id="constraints-on-specializationgeneralization" class="section level3">
<h3>Constraints on specialization/generalization</h3>
</div>
</div>
<div id="functional-dependencies" class="section level2">
<h2>Functional Dependencies</h2>
<ul>
<li><p>database design quality</p>
<ul>
<li>completeness: has all relevant info been captured?</li>
<li>redundancy freeness: has the doubling of relevant info been avoided?</li>
<li>consistent understanding: is the meaning of all relevant info consistent? is the meaning of <code>NULL</code> clear?
<ul>
<li>counterexample: contradicting rows!</li>
</ul></li>
<li>performance</li>
</ul></li>
<li><p><strong>Functional dependencies (FDs)</strong> are developed to defined the goodness and badness of relational database design in a formal way.</p>
<ul>
<li>top down: start with a relation schema and FDs -&gt; smaller relation schemas in certain normal form (normalization)</li>
<li>bottom up: start with attributes and FDs -&gt; relation schemas (not popular in practice)</li>
</ul></li>
<li><p><code>{StudentID} -&gt; {Name, DoB}</code>, <strong>functionally determines</strong></p></li>
<li><p>A <strong>FD</strong> says that within a relation, the values of some attributes determine the values of other attributes.</p></li>
<li><p><code>{A,B,C} -&gt; {D,E}</code>, A, B, C are the <strong>determinant</strong>, D, E are the <strong>dependent</strong>.</p></li>
<li><p><code>{A,B,C} -&gt; {A,B}</code> is <strong>trivial</strong>.</p></li>
<li><p>keys</p>
<ul>
<li>a subset of the attributes of a relation schema <span class="math inline">\(R\)</span> is a <strong>superkey</strong> if it uniquely determines all attributes of <span class="math inline">\(R\)</span>.</li>
<li>a superkey <span class="math inline">\(K\)</span> is called a <strong>candidate key</strong> if no proper subset of <span class="math inline">\(K\)</span> is a superkey.</li>
<li><strong>candidate keys</strong> are also called <strong>keys</strong>, and the <strong>primary key</strong> is chosen from them.</li>
</ul></li>
<li><p>Given a set <span class="math inline">\(\Sigma\)</span> of FDs on a relation <span class="math inline">\(R\)</span>, let <span class="math inline">\(\Sigma*\)</span> be all possible FDs <strong>implied</strong> by <span class="math inline">\(\Sigma\)</span>.</p></li>
<li><p>A <strong>prime attribute</strong> is an attribute occuring in a key, and a <strong>non-prime attribute</strong> is an attribute that is not a prime attribute.</p></li>
</ul>
<p>e.g. <span class="math inline">\(R=\{A,B,C,D\}, \Sigma=\{AB\rightarrow C, AC\rightarrow D\}\)</span></p>
<p>Solution:</p>
<p>(A)+ = A, (B)+ = B, (C)+ = C, (D)+ = D.
(AB)+ = ABCD, (AC)+ = ACD, (AD)+ = AD, (BC)+ = BC, (BD)+ = BD, (CD)+ = CD
(ABC)+ = ABCD, (ABD)+ = ABCD, (ACD)+ = ACD, (BCD)+ = BCD</p>
<p>hence, AB is the only key of <span class="math inline">\(R\)</span>, AB, ABC, ABD and ABCD are the superkeys of <span class="math inline">\(R\)</span>. A, B are the prime attributes of <span class="math inline">\(R\)</span>.</p>
<ul>
<li>Tricks:
<ul>
<li>if an attribute never appears in the dependent of any FD, this attribute must be part of each key</li>
<li>if an attribute never appears in the determinant of any FD but appears in the dependent of any FD, this attribute must not be part of each key</li>
<li>if a proper subset of <span class="math inline">\(X\)</span> is a key, then <span class="math inline">\(X\)</span> must not be a key</li>
</ul></li>
</ul>
</div>
<div id="normalization" class="section level2">
<h2>Normalization</h2>
<ul>
<li><p>normal form: 1NF =&gt; 2NF =&gt; 3NF =&gt; BCNF (Test criteria from weak to strong)</p></li>
<li><p>decomposing a relation into <strong>smaller relations in a certain normal form</strong></p>
<ul>
<li>each normal form reduces certain kind of data redundancy</li>
<li>each normal form does not have certain types of dependencies</li>
</ul></li>
</ul>
<div id="bcnf" class="section level3">
<h3>BCNF</h3>
<ul>
<li><strong>Boyce-Codd normal form (BCNF)</strong>: A relation schema <span class="math inline">\(R\)</span> is in BCNF if whenever a non-trivial FD <span class="math inline">\(X\rightarrow A\)</span> holds in <span class="math inline">\(R\)</span>, then <span class="math inline">\(X\)</span> is a superkey.
<ul>
<li>when a relation schema is in BCNF, all data redundancy based on functional dependency are removed
<ul>
<li>but not necessarily a good design</li>
</ul></li>
</ul></li>
<li>2 things to consider when decomposing a relation:
<ul>
<li><strong>lossless join</strong> – capture the same data</li>
<li><strong>dependency preservation</strong> – capture the same meta-data</li>
</ul></li>
<li>facts:
<ul>
<li>an algorithm exists that can genrate a lossless decomposition into BCNF</li>
<li>a BCNF decomposition that is both lossless and dependency-preserving does not always exist</li>
</ul></li>
</ul>
</div>
<div id="nf" class="section level3">
<h3>3NF</h3>
<ul>
<li><strong>Third normal form (3NF)</strong>: less restrictive normal form
<ul>
<li>A relation schema <span class="math inline">\(R\)</span> is in 3NF if whenever a non-trivial FD <span class="math inline">\(X\rightarrow A\)</span> holds in <span class="math inline">\(R\)</span>, then <span class="math inline">\(X\)</span> is a superkey or <span class="math inline">\(A\)</span> is prime attribute.</li>
<li>3NF allows data redundancy but excludes relation schemas with certain kinds of FDs.</li>
</ul></li>
<li><strong>Minimal Cover</strong>
<ul>
<li><span class="math inline">\(\Sigma\)</span> is a set of FDs, a minimal cover <span class="math inline">\(\Sigma_m\)</span> of <span class="math inline">\(\Sigma\)</span> is a set of FDs s.t.
<ul>
<li><span class="math inline">\(\Sigma_m\)</span> is equivalent to <span class="math inline">\(\Sigma\)</span></li>
<li><strong>Dependent</strong>: each FD in <span class="math inline">\(\Sigma_m\)</span> has only <strong>one single attribute on its right hand side</strong>, replace each FD <span class="math inline">\(X\rightarrow\{A_1,\dots,A_k\}\)</span> in <span class="math inline">\(\Sigma_m\)</span> with <span class="math inline">\(X\rightarrow A_1,\dots, X\rightarrow A_k\)</span>;</li>
<li><strong>Determinant</strong>: each FD as few attributes on the LHS as possible, for each FD <span class="math inline">\(X\rightarrow A\)</span> in <span class="math inline">\(\Sigma_m\)</span>, check each attribute <span class="math inline">\(B\)</span> of <span class="math inline">\(X\)</span> to see if we can replace <span class="math inline">\(X\rightarrow A\)</span> with <span class="math inline">\((X-B)\rightarrow B\)</span> in <span class="math inline">\(\Sigma_m\)</span>;</li>
<li>Remove a FD from <span class="math inline">\(\Sigma_m\)</span> if its is redundant.</li>
</ul></li>
<li>A minimal cover of a set of FD <span class="math inline">\(\Sigma\)</span> always exists but not necessarily unique.</li>
</ul></li>
</ul>
<p>e.g. <span class="math inline">\(\Sigma=\{A\to BC, B\to C, B\to A, C\to AB\}\)</span> has two possible minimal covers</p>
<ul>
<li><p>then, let <span class="math inline">\(R_i\)</span> be the i-th FD in the minimal cover, remove any omittable <span class="math inline">\(R_i\)</span>’s if <span class="math inline">\(R_i\subseteq R_j\)</span>.</p></li>
<li><p>Finally, the 3NF-decomposition is <span class="math inline">\(\{R_i, \dots,\}\)</span></p></li>
<li><p>normalziation process may degrade performance when data are frequentyl queried</p>
<ul>
<li>queries need to join many relations together, join is expensive</li>
</ul></li>
<li><p>denormaliztion</p>
<ul>
<li>after normalziation process</li>
<li>during the physical design stage</li>
<li>reduces the number of relations that need to be joined for certain queries</li>
</ul></li>
<li><p>unnormalized – no systematic design</p></li>
<li><p>normalized – redundancy is reduced after a systematic design</p></li>
<li><p>denormalized – redundancy is introduced after analysing the normalized design</p></li>
<li><p>a trade-off</p></li>
</ul>
</div>
</div>
<div id="relational-algebra" class="section level2">
<h2>Relational Algebra</h2>
<ul>
<li>Relational algebra (RA)
<ul>
<li>a query language for relational db</li>
<li>not visible from user interface, but at the core of SQL</li>
<li>used by relational DBMSs internally for representing and optimizing SQL queries</li>
</ul></li>
<li>relational operators
<ul>
<li>selection (rows)
<ul>
<li><span class="math inline">\(\sigma_\phi (R)\)</span> choose tuples that satisfy the condition <span class="math inline">\(\phi\)</span> from a relation <span class="math inline">\(R\)</span>, e.g. <span class="math inline">\(\sigma_\text{semester=&#39;2016 S2&#39;}(\text{Course})\)</span></li>
<li>selection yields the same attributes as <span class="math inline">\(R\)</span></li>
<li>selection is <strong>commutative</strong></li>
</ul></li>
<li>projection (columns)
<ul>
<li><span class="math inline">\(\pi_{A_1,\dots,A_n}(R)\)</span></li>
<li>projection has no duplicates (in SQL, we have <code>DISTINCT</code>)</li>
<li>can be used to reorder attributes</li>
<li>not commutative</li>
</ul></li>
<li>renaming (of attributes or the relations)
<ul>
<li><span class="math inline">\(\rho_{R&#39;(A_1,\dots,A_n)}(R)\)</span></li>
<li><span class="math inline">\(\rho_{R&#39;}(R)\)</span></li>
<li><span class="math inline">\(\rho_{(A_1,\dots,A_n)}(R)\)</span></li>
</ul></li>
<li>union, intersection, difference</li>
<li>cartesian product and join
<ul>
<li><span class="math inline">\(R_1\times R_2\)</span></li>
<li><span class="math inline">\(R_1\bowtie_\phi R_2=\sigma_\phi(R_1\times R_2)\)</span></li>
</ul></li>
</ul></li>
<li>we call selection, projection, renaming, union, difference, cartesian product <strong>a complete set</strong>, since
<ul>
<li><span class="math inline">\(R_1\bowtie_\phi R_2=\sigma_\phi(R_1\times R_2)\)</span> and</li>
<li><span class="math inline">\(R_1\cap R_2=R_1-(R_1-R_2)\)</span></li>
</ul></li>
</ul>
<div id="equivalence-of-ra-and-sql-queries" class="section level3">
<h3>equivalence of RA and SQL queries:</h3>
<ul>
<li>Selection</li>
</ul>
<pre class="sql"><code>SELECT DISTINCT * FROM R WHERE CONDITION;</code></pre>
<ul>
<li>Projection</li>
</ul>
<pre class="sql"><code>SELECT DISTINCT A1,...An FROM R;</code></pre>
<ul>
<li>Renaming</li>
</ul>
<pre class="sql"><code>SELECT A1 AS B1,...,An AS Bn FROM R AS S;</code></pre>
<ul>
<li>Union</li>
</ul>
<pre class="sql"><code>SELECT * FROM R1 UNION SELECT * FROM R2;</code></pre>
<ul>
<li>Intersection</li>
</ul>
<pre class="sql"><code>SELECT * FROM R1 INTERSECT SELEC * FROM R2;</code></pre>
<ul>
<li>Difference</li>
</ul>
<pre class="sql"><code>SELECT * FROM R1 EXCEPT SELECT * FROM R2;
SELECT DISTINCT * FROM R1 WHERE NOT EXISTS (SELECT * FROM R2 WHERE R1.A1=R2.A1 AND ... AND R1.An=R2.An);</code></pre>
<ul>
<li>Cartesian product</li>
</ul>
<pre class="sql"><code>SELECT * FROM R1, R2;</code></pre>
<ul>
<li>Join</li>
</ul>
<pre class="sql"><code>SELECT DISTINCT * FROM R1 INNER JOIN R2 ON CONDITION;</code></pre>
<ul>
<li>Natural join</li>
</ul>
<pre class="sql"><code>SELECT DISTINCT * FROM R1 NATURAL JOIN R2;</code></pre>
<hr />
<p>2018-10-05</p>
</div>
</div>
<div id="query-processing-and-optimization" class="section level2">
<h2>Query Processing and Optimization</h2>
<ul>
<li>example:
<ul>
<li>High-level language (SQL) -&gt;
<ul>
<li>Low-level language (RA) -&gt;
<ul>
<li>Execution plan (Query tree) -&gt;
<ul>
<li>Query result</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<div id="query-processing" class="section level3">
<h3>Query Processing</h3>
<ul>
<li>processing steps
<ul>
<li>query parser and translator
<ul>
<li><strong>parser</strong> checks the syntax of the query
<ul>
<li>validation of table names, attributes, data types, access permission …</li>
<li>either the query is executable or an error message is generated</li>
</ul></li>
<li>the <strong>translator</strong> translates queries into RA expressions
<ul>
<li>a query is first decomposed into <strong>query blocks</strong></li>
<li>each query block is translated into an RA expression</li>
</ul></li>
<li>(1). check the syntax of SQL queries</li>
<li>(2). verify the relations do exist</li>
<li>(3). transform into RA expressions</li>
</ul></li>
<li>query optimizer
<ul>
<li>one sql query -&gt; many possible execution plans</li>
<li>optimizer is responsible for identifying an efficient execution plan
<ul>
<li>enumerating alternative plans</li>
<li>choosing the one with the least estimated cost</li>
</ul></li>
<li>(1). transform into the best possible execution plan</li>
<li>(2). specify the implementation of each operator in the execution plan</li>
</ul></li>
<li>evaluation engine
<ul>
<li>(1). evaluate the query execution plan</li>
<li>(2). return the result to the user</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="query-optimization" class="section level3">
<h3>Query Optimization</h3>
<ul>
<li>optimizers incorporate elements of the following 3 op approaches:
<ul>
<li>Semantic query optimization: Use application speciﬁc semantic knowledge to transform a query into the one with a lower cost (they return the same answer).</li>
<li>Rule-based query optimisation: Use heuristic rules to transform a relational algebra expression into an equivalent one with a possibly lower cost.</li>
<li>Cost-based query optimisation: Use a cost model to estimate the costs of plans, and then select the most cost-effective plan.</li>
</ul></li>
</ul>
</div>
</div>
<div id="db-security" class="section level2">
<h2>DB Security</h2>
<ul>
<li>db security (against 2 cases):
<ul>
<li>stop users without db access from having any access:</li>
<li>stop users with db access from performing actions on the db which are not required to perform their duties</li>
</ul></li>
</ul>
<p>db security = confidentiality + integrity + availability</p>
<ul>
<li>control measures
<ul>
<li>accesss control
<ul>
<li>restrict access to database system
<ul>
<li>e.g. user and pswds</li>
</ul></li>
</ul></li>
<li>inference control
<ul>
<li>ensure the data that users are not authorized to access cannot be inferred from statistical or summary data
<ul>
<li>e.g. know the average salary of a department, but don’t know the salary of a particular person.</li>
</ul></li>
</ul></li>
<li>flow control
<ul>
<li>prevent data to ﬂow into unauthorized users,
<ul>
<li>e.g. avoid covert channels</li>
</ul></li>
</ul></li>
<li>data encryption
<ul>
<li>protect sensitive data during storage and transmission,
<ul>
<li>e.g. pswds and credit card info</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<div id="access-control" class="section level3">
<h3>access control</h3>
<ul>
<li>access control: authentication + authorization + additional measures (such as IP-based restrictions)
<ul>
<li><strong>authentication</strong> is the process by which a system can identify users</li>
<li><strong>authorization</strong> is the process by which a system determines what level of access a user (who is already authenticated) has to secured resources.</li>
<li>main approaches to access control
<ul>
<li><strong>Discretionary access control (DAC)</strong>
<ul>
<li>Based on the concept of access privileges for giving users such privileges.</li>
<li>SQL support DAC; most commercial DBMSs also support DAC.
<ul>
<li>through <code>GRANT</code> and <code>REVOKE</code> commands
<ul>
<li><code>GRANT</code> gives privileges to users</li>
<li><code>REVOKE</code> takes away privileges from users</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Mandatory access control (MAC)</strong>
<ul>
<li>Based on system-wide policies that cannot be changed by individual users.</li>
<li>SQL doesn’t support MAC but some DBMSs support MAC.</li>
</ul></li>
<li><strong>Role-based access control (RBAC)</strong>
<ul>
<li>Based on roles (can be used with DAC and MAC).</li>
<li>SQL support privileges on roles; many DBMSs support RBAC.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="sql-injection" class="section level3">
<h3>SQL injection</h3>
<ul>
<li>In SQL injection attacks, hackers inject a string input through the Web application which changes the SQL statement to their advantages.</li>
</ul>
<p>e.g.</p>
<pre class="sql"><code>SELECT * FROM users WHERE name=‘jake’ AND password=‘p’ OR ‘x’=‘x’;

SELECT * FROM users WHERE name=‘jake’ AND password=‘p’; DROP TABLE users; --;’;</code></pre>
<blockquote>
<p>Because the query here is constructed from strings, the use of quotes has turned the original WHERE condition into a condition that is always true.</p>
</blockquote>
<ul>
<li>protection techniques
<ul>
<li>Parameterized queries is used to improve security by preventing SQL injection (best solution).</li>
<li>Input validation is used to remove or escape characters from input strings.</li>
</ul></li>
</ul>
</div>
</div>
<div id="db-transactions" class="section level2">
<h2>DB Transactions</h2>
<p>DBMSs provide transaction support for solving this kind of problem.</p>
<p>A transaction is a sequence of database operations grouped together for execution as a logic unit in a DBMS.</p>
<p>Database applications often access a database by transactions rather than individual operations.</p>
<p>They can enforce data integrity in the following situations:</p>
<ul>
<li><p>multiple users may modify and share data at the same time;</p></li>
<li><p>transaction, system, and media failures may happen from time to time.</p></li>
<li><p>look like:</p>
<ul>
<li><code>INSERT, SELECT, UPDATE, DELETE, BEGIN, COMMIT, ABORT (ROLLBACK)</code>, etc. from a high-level language perspective;</li>
<li><code>read, write, begin, commit, abort</code> at the internal process level.</li>
</ul></li>
</ul>
<p>e.g.</p>
<pre class="sql"><code>BEGIN TRANSACTION
SELECT balance FROM Account WHERE name = ‘Steve’;
UPDATE Account
SET balance = balance-500 WHERE name=‘Steve’;
SELECT balance FROM Account WHERE name = ‘Bob’;
UPDATE Account
SET balance = balance+500 WHERE name = ‘Bob’;
COMMIT</code></pre>
<div id="acid-properties" class="section level3">
<h3>ACID properties</h3>
<ul>
<li>DBMSs ensure the following properties of transactions.
<ul>
<li><strong>Atomicity:</strong>
<ul>
<li>The execution of each transaction is atomic, i.e., <strong>either all operations are completed or not done at all.</strong></li>
</ul></li>
<li><strong>Consistency:</strong>
<ul>
<li>The states of a database are consistent (w.r.t. deﬁned business rules) <strong>before and after each transaction.</strong></li>
</ul></li>
<li><strong>Isolation:</strong>
<ul>
<li>Execution results of each transaction should be <strong>unaffected by other concurrent executing transactions.</strong></li>
</ul></li>
<li><strong>Durability:</strong>
<ul>
<li>Once a transaction has been successfully completed, <strong>its effects should persist in the database.</strong></li>
</ul></li>
</ul></li>
<li>Note: These properties are not independent from one another, but <strong>atomicity is the central property.</strong></li>
</ul>
</div>
<div id="concurrent-transactions" class="section level3">
<h3>Concurrent Transactions</h3>
<ul>
<li><p><strong>interleaved processing</strong>: transactions are interleaved in s single CPU.</p></li>
<li><p><strong>parallel processing</strong>: transactions are executed in parallel in multiple CPUs.</p></li>
<li><p>Either way, executing transactions concurrently will <strong>improve database performance</strong></p>
<ul>
<li>Increase throughput (average number of completed transactions)</li>
<li>Reduce latency (average time to complete a transaction)</li>
</ul></li>
<li><p>But the DBMS has to guarantee that the interleaving of transactions does not lead to inconsistencies, i.e., <strong>concurrency control</strong>.</p>
<ul>
<li>prevents:
<ul>
<li><strong>lost update</strong> problem: Occurs when two transactions update the same object, and one transaction could overwrite the value of the object which has already been updated by another transaction (write-write conﬂicts).</li>
<li><strong>dirty read</strong> problem: Occurs when one transaction could read the value of an object that has been updated by another transaction but has not yet committed (write-read conﬂicts).</li>
<li><strong>unrepeated read</strong> problem: A transaction could change the value of an object that has been read by another transaction but is still in progress (could issue two read for the object, or a write after reading the object) (read-write conﬂicts).</li>
<li><strong>phantom read</strong> problem: Occurs when tuples updated by a transaction T 1 satisfy the search conditions of another transaction so that, by the same search condition, the transaction obtains different results at different times.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="nosql-db" class="section level2">
<h2>NoSQL DB</h2>
<ul>
<li><p>why need NoSQL? Big data</p>
<ul>
<li>scale large</li>
<li>nature of big data: 3Vs (volume, velocity, variety)</li>
</ul></li>
<li><p>NoSQL</p>
<ul>
<li>flexibility of schemas:
<ul>
<li>relational modeling is driven by the structure of available data</li>
<li>NoSQL modeling is driven by application-specific operation patterns</li>
<li>relational dbs are not good for managing hierarchical or graph-like data, but many NoSQLs are</li>
<li>relational dbs require pre-defined schemas but NoSQL have no fixed schemas</li>
</ul></li>
<li>scalability:
<ul>
<li>many NoSQL databases are driven by the need to scale
<ul>
<li><strong>shared-nothing (SN)</strong> vs <strong>shared-everything (SE)</strong></li>
<li><strong>scale up (vertically)</strong> vs <strong>scale out (horizontally)</strong></li>
</ul></li>
<li>relational databases can scale up by getting faster hardware, but cannot easily scale out at an acceptable cost and beyond certain point under ACID constraints.</li>
<li>NoSQL databases often designed to scale out by leveraging commodity hardware, and free software, providing an inexpensive solution for scalability</li>
</ul></li>
<li>performance:
<ul>
<li>Relational databases were invented in a way that implementation techniques are abstracted away from the user.</li>
<li>NoSQL databases promote exposing the implementation techniques to the programmer</li>
<li>Query performance is often one of the strengths of NoSQL databases, particularly when handling complex-valued data (because they de-normalise data and don’t use join).</li>
</ul></li>
<li>cost:
<ul>
<li>NoSQL solutions are often less expensive than RDBMSs, especially when dealing with large-scale data sets.</li>
<li>A scale out approach is usually cheaper than the scale up alternative.
<ul>
<li>Many NoSQL databases are open source, while licensing costs of commercial RDBMSs can be quite expensive.</li>
<li>NoSQL databases often leverage commodity servers to scale out, while RDBMs tends to rely on expensive proprietary servers and storage systems</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>RDBMSs support the ACID properties for database transactions.</p></li>
<li><p>NoSQL often uses a model weaker than ACID, called BASE.</p>
<ul>
<li>Basically available: The system may have partial failures. If a single node fails, part of the data won’t be available, but the entire data layer stays operational.</li>
<li>Soft state: The state of the system could change over time (even during times without input), because there may be changes going on due to “eventual consistency”.</li>
<li>Eventual consistency: Given a sufﬁciently long period of time, all updates can be expected to propagate eventually through the system and the replicas will be consistent.</li>
</ul></li>
<li><p>There is a continuum between ACID and BASE in distributed database systems.</p></li>
<li><p>NoSQL databases are mainly categorized according to their data models:</p>
<ul>
<li>Key-value data stores</li>
<li>Column-oriented data stores</li>
<li>Document-oriented data stores</li>
<li>Graph databases</li>
<li>(size decreases, complexity increases)</li>
</ul></li>
</ul>
<div id="key-value-data-stores" class="section level3">
<h3>Key-value Data Stores</h3>
<ul>
<li>The simplest type of NoSQL databases to use from an API perspective (the implementation may be complex) Look like a simple hash table (i.e., a unique key and a value), but not – it is a big, distributed, fault-tolerant, persistent hash table!</li>
<li>The schema of a key-value data store is: <strong>Key</strong> and <strong>Value</strong> (<strong>Key</strong> is a <strong>string</strong> and <strong>Value</strong> is a <strong>blob</strong>).</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Peter, M, 03-07-1990, 34 Wattle St, ﬁshing</td>
</tr>
<tr class="even">
<td>2</td>
<td>Tom, M, 01-09-1995, 3 Arnold St, swimming</td>
</tr>
</tbody>
</table>
<ul>
<li>Highly scalable, and there are two major options for scaling
<ul>
<li><strong>Partitioning</strong>: data is partitioned so that each database has a subset of the data stored on local disks.</li>
<li><strong>Replication</strong>: data is copied so that more than one database has the same data stored on local disks.</li>
</ul></li>
<li>Concurrency is only applicable on a single key, and concurrency conﬂict is thus easy to handle.</li>
<li>Can <strong>gain signiﬁcant performance beneﬁt</strong> when structuring data access along keys for right applications, e.g. Amazons shopping cart runs on a key-value store (Amazon Dynamo).</li>
<li>If you need complex operations on values, you should look at other solutions, such as document-oriented data stores.</li>
</ul>
</div>
<div id="column-oriented-data-stores" class="section level3">
<h3>Column-oriented Data Stores</h3>
<ul>
<li><p>Store data grouped by columns (rather than rows) and may have a very What is a column-store? large number of columns.</p></li>
<li><p>Uses a <strong>shared-nothing architecture</strong> to provide scalability over massive data sets:</p>
<ul>
<li><strong>Horizontal partitioning</strong> by range of row keys.</li>
<li><strong>Vertical partitioning</strong> by column families</li>
</ul></li>
<li><p><strong>Replication</strong>: eventual-consistency replication across datacenters, between multiple BigTable serving setups (master/slave &amp; multi-master)</p></li>
<li><p>Supports <strong>single-row transactions</strong>.</p></li>
<li><p>Supports <strong>only simple queries</strong>.</p></li>
<li><p>Does <strong>not support secondary indices</strong>.</p></li>
</ul>
</div>
</div>
